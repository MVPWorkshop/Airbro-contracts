// SPDX-License-Identifier:UNLICENSED
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
// import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract TestNFT is Ownable, ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    // uint256 tokenId;
    mapping(address => tokenMetaData[]) public ownershipRecord;
    address selected = 0xa120690093Dcd21a987c02eEB5f1E0B851B940a5;

    uint256 interval; // in seconds
    uint256 lastTimeStamp;

    struct tokenMetaData {
        uint256 tokenId;
        uint256 timeStampCreated;
        uint256 timeStamp;
        string tokenURI;
        string twitterHandle;
    }

    event SelectChanged(address indexed selectedAddress);

    constructor(uint256 _interval) ERC721("AIRBROdNFTs", "dNFT") {
        interval = _interval;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            // do some cool keeper stuff
            if (ownershipRecord[selected][0].timeStampCreated != 0) ownershipRecord[selected][0].timeStamp = block.timestamp;
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function mintToken(string calldata _twitterHandle) public onlyOwner {
        require(owner() != msg.sender, "Recipient cannot be the owner of the contract");

        uint256 tokenId = _tokenIdCounter.current();
        _safeMint(msg.sender, tokenId);

        ownershipRecord[msg.sender].push(
            tokenMetaData(
                tokenId,
                block.timestamp,
                block.timestamp,
                "https://miro.medium.com/max/1120/1*k_EY7dcLYB5Z5k8zhMcv6g.png",
                _twitterHandle
            )
        );
        _tokenIdCounter.increment();
    }

    /// @notice Updates the selected address of the selected variable
    /// @param _newSelect - New address for the admin of this contract, and the address for all newly created airdrop contracts
    function changeSelected(address _newSelect) external onlyOwner {
        selected = _newSelect;
        emit SelectChanged(_newSelect);
    }
}
